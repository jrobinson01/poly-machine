<script>
/** @typedef {!{event:string, target:string, condition:function}} */
let Transition;
/** @typedef {!{name: string, transitions: Array<Transition>, onEntry:function, onExit:function}} */
let State;

  /** @polymerMixin */
  const polyMachineMixin = (superclass) => class PolyMachineMixin extends superclass {

    static get properties() {
      return {
        // TODO: should 'state' be settable via data binding?
        state: {
          type: String,
          reflectToAttribute: false,
          notify: true,
          readOnly: true
        },
        states: {
          type: Object,
          readOnly: true,
          value: () => ({})
        },
        initialState: String
      };
    }

    constructor() {
      super();
      this.state_;
      this.initializeState_(this.states);
    }

    initializeState_(states) {
      const initial = this.getStateByName(this.initialState);
      if (initial) {
        this.transitionTo_(initial);
      } else {
        throw new Error(`'initialState' is not set`);
      }
    }

    /**
     * @param {string} state
     * @param {State} desired
     * @return {boolean}
     */
    isState(state, desired) {
      return state === desired.name;
    }


    /**
     * @param {string} state
     * @param {Array<State>} states
     * @return {boolean}
     */
    oneOfState(state, ...states) {
      return Boolean(states && states.findIndex(s => s.name === state) >= 0);
    }

    /**
     * @description attempt to transition to the next state
     * @param {State} newState
     * @param {object} detail
     */
    transitionTo_(newState, detail) {
      if (!newState) {
        throw new Error(`no state provided!`);
      }
      // prevent setting same state
      if (newState === this.state_) {
        return;
      }
      // call onExit if exists
      if (this.state_ && this.state_.onExit) {
        this.state_.onExit.call(this);
      }
      this.state_ = newState;
      // state property is readonly, use special polymer method to set
      this.state = this._setState(newState.name);
      // call onEntry if it exists
      if (newState.onEntry) {
        newState.onEntry.call(this, detail);
      }
    }

    /**
     * @param {string} name
     * @return {?State}
     */
    getStateByName(name) {
      return Object.values(this.states).find(s => s.name === name);
    }

    /**
     * @description dispatches an event that our state machine consumes
     * @param {string} eventName
     * @param {object} detail
     */
    send(eventName, detail) {
      if (!eventName) {
        throw new Error('an event name is required to send!');
      }
      if (!this.state_) {
        throw new Error(`cannot send with no state: ${eventName}`);
      }
      // find the appropriate transitions in the current state
      const transitions = this.state_.transitions.filter(t => t.event === eventName);
      // no matching transitions in this state
      if (transitions.length === 0) {
        return;
      }
      // check each transition for conditions and throw an error, for now, if any transition does not have conditions.
      if (transitions.length > 1 && transitions.filter(t => !t.conditions).length > 0) {
        throw new Error(`multiple transitions found without conditions for event: ${eventName} in state: ${this.state}`);
      }
      // if multiple transitions, run the first one that has a condition that returns true.
      if (transitions.length > 1) {
        transitions.some(t => {
          const passed = t.conditions.reduce((p, c) => {
            return p ? p : p = c.call(this);
          }, false);
          if (passed) {
            // run the first passing transition
            this.transitionTo_(this.getStateByName(t.target), detail);
          }
          return passed;// break out of loop before testing more conditions
        });
      } else {
        // only one transition, check for conditions first
        const transition = transitions[0];
        // go for it if no conditions
        if (!transition.conditions) {
          return this.transitionTo_(this.getStateByName(transition.target), detail);
        } else {
          // if the transition does have conditions,
          // transitionTo_ on the first condition that returns true
          const passed = transition.conditions.reduce((p, c) => {
            return p ? p : p = c.call(this);
          }, false);
          if (passed) {
            return this.transitionTo_(this.getStateByName(transition.target), detail);
          }
        }
      }
    }
  }
</script>
