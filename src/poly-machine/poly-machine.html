<script>
  /** @polymerMixin */
  const polyMachineMixin = (superclass) => class PolyMachineMixin extends superclass {

    static get properties() {
      return {
        // TODO: 'state' should be settable via data binding
        state: {
          type: String,
          reflectToAttribute: true,
          notify: true,
          readOnly: true
        },
        states: {
          type: Object,
          readOnly: true,
          value: () => ({})
        },
        initialState: String
      };
    }

    constructor() {
      super();
      this.state_;
      this.initializeStateListeners_(this.states);
      this.initializeState_(this.states);
    }

    createStateListener_(state) {
      state.events.forEach(o => {
        this.addEventListener(o.event, event => {
          // ignore event if we're not in the state that defines this listener
          if(this.state !== state.name) {
            return;
          }
          // check conditions if exists
          if(!o.cond || o.cond.apply(this)) {
            // condition passes, setState
            this.setState(this.getStateByName(o.target));
          }
        });
      })
    }

    initializeStateListeners_(states) {
      for(let key in states) {
        this.createStateListener_(states[key]);
      }
    }

    initializeState_(states) {
      const values = Object.values(states);
      const initial = values.find(v => v.name === this.initialState);
      if (initial) {
        this.setState(initial);
      } else {
        throw new Error('initialState is not set');
      }
    }

    isState(state, desired) {
      return state === desired.name;
    }

    oneOfState(state, ...states) {
      return Boolean(states && states.findIndex(s => s.name === state) >= 0);
    }

    setState(newState) {
      if (!newState) {
        throw new Error(`attempted to enter illegal state: ${newState}`);
      }
      // prevent setting same state
      if (newState === this.state_) {
        return;
      }
      this.state_ = newState;
      this.state = this._setState(newState.name);// state property is readonly, use special method to set
      if (newState.onEntry) {
        newState.onEntry.apply(this);
      }
    }

    getStateByName(name) {
      return Object.values(this.states).find(s => s.name === name);
    }

    /**
     * @description dispatches an event that our state machine consumes
     * @param {string} eventName
     */
    send(eventName) {
      if (eventName) {
        this.dispatchEvent(new CustomEvent(eventName));
      }
    }

  }
</script>
